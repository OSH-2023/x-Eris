# MMU （内存管理单元）
> 暂时搁置
## 简介
负责处理 CPU 的内存访问请求，主要负责虚拟内存地址到物理内存地址的转换（虚拟内存管理）、内存保护、中央处理器高速缓存的控制。

每条MMU匹配规则（虚拟地址-物理地址）所对应的存储器的大小定义为页。页的大小通常设定为不会对程序的性能造成显著影响的最小的程序和代码的长度。当暂时不使用物理内存的内容时，可将其保存到硬盘等外部存储器里，将其空间用于其他程序;当再次使用这部分内容时再从外部存储器写回到实际物理内存中。通过这种方法，系统就可以提供多于实际物理内存容量的 **“虚拟内存”**。

> 如果MMU定义的页太大，那么进行虚拟内存页面替换所花费的时间就太长；如果页太小，就会引起过于频繁的页面替换。通常最小的页设定为4 KB。 

为了加快MMU规则匹配的处理过程，有效地址和实际物理地址的对应表通常保存在一块单独的高速缓存中，称为对应查找表(Translation Lookaside Buffer，TLB)，TLB和实际物理存储器可以同时进行并行的访问。有效地址的高位作为在TLB进行匹配查找的依据，而有效地址的低位作为页面内的偏址。
## 功能
* 将线性地址映射为物理地址

* 提供硬件机制的内存访问授权
  
多年以来，微处理器一直带有片上存储器管理单元（MMU），MMU能使单个软件线程工作于硬件保护地址空间。但是在许多商用实时操作系统中，即使系统中含有这些硬件也没采用MMU。 
当应用程序的所有线程共享同一存储器空间时，任何一个线程将有意或无意地破坏其它线程的代码、数据或堆栈。异常线程甚至可能破坏内核代码或内部数据结构。例如线程中的指针错误就能轻易使整个系统崩溃，或至少导致系统工作异常。 

就安全性和可靠性而言，基于进程的实时操作系统（RTOS）的性能更为优越。为生成具有单独地址空间的进程，RTOS只需要生成一些基于RAM的数据结构并使MMU加强对这些数据结构的保护。基本思路是在每个关联转换中“接入”一组新的逻辑地址。MMU利用当前映射，将在指令调用或数据读写过程中使用的逻辑地址映射为存储器物理地址。MMU还标记对非法逻辑地址进行的访问，这些非法逻辑地址并没有映射到任何物理地址。

这些进程虽然增加了利用查询表访问存储器所固有的系统开销，但其实现的效益很高。在进程边界处，疏忽或错误操作将不会出现，用户接口线程中的缺陷并不会导致其它更关键线程的代码或数据遭到破坏。在可靠性和安全性要求很高的复杂嵌入式系统中，仍然存在采无存储器保护的操作系统的情况，这实在有些不可思议。 

采用MMU还有利于选择性地将页面映射或解映射到逻辑地址空间。物理存储器页面映射至逻辑空间，以保持当前进程的代码，其余页面则用于数据映射。类似地，物理存储器页面通过映射可保持进程的线程堆栈。RTOS可以在每个线程堆栈解映射之后，很容易地保留逻辑地址所对应的页面内容。这样，如果任何线程分配的堆栈发生溢出，将产生硬件存储器保护故障，内核将挂起该线程，而不使其破坏位于该地址空间中的其它重要存储器区，如另一线程堆栈。这不仅在线程之间，还在同一地址空间之间增加了存储器保护。 

存储器保护（包括这类堆栈溢出检测）在应用程序开发中通常非常有效。采用了存储器保护，程序错误将产生异常并能被立即检测，它由源代码进行跟踪。如果没有存储器保护，程序错误将导致一些细微的难以跟踪的故障。实际上，由于在扁平存储器模型中，RAM通常位于物理地址的零页面，因此甚至NULL指针引用的解除都无法检测到。